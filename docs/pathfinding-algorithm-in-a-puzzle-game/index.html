<!doctype html><html lang="en"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1" name="viewport"><title>Pathfinding algorithm in a puzzle game</title><meta content="How to find a path between two selected locations in a puzzle game with items on a grid" name="description"><meta content="Pathfinding algorithm in a puzzle game" property="og:title"><meta content="How to find a path between two selected locations in a puzzle game with items on a grid" property="og:description"><meta content="article" property="og:type"><style>body,html{margin:0 0}body{color:#222;font-size:18px;line-height:1.5}.header-content,article,footer{margin:0 auto;padding:0 15px;max-width:710px}h1{border-bottom:2px solid #ffd744;padding-bottom:15px;font-size:32px}.blog-name{text-align:center;padding-bottom:25px}h2{font-size:24px}h3{font-size:20px}a{text-decoration:none;color:#927200;transition:color .25s ease-out}a:hover{color:#bb9200}code{font-size:14px}pre{overflow:auto}img{max-width:100%}.footer-content{margin-top:15px;border-top:2px solid #ffd744;padding-top:15px;padding-bottom:15px}.art-list-link{font-size:22px;margin-bottom:5px}.art-list-link a{color:#222;transition:color .2s ease-out}.art-list-link a:hover{color:#555}.art-list-date{font-size:16px}@media (prefers-color-scheme:dark){body{background:#222;color:#fff}a{color:#ffd744}a:hover{color:#bb9200}.art-list-link a{color:#fff}.art-list-link a:hover{color:#eee}}@media (min-width:768px){body{font-size:20px}code{font-size:16px}}</style><link href="/img/favicon.svg" rel="icon" type="image/svg+xml"><link href="/img/favicon.ico" rel="alternate icon"></head><body><article><h1>Pathfinding algorithm in a puzzle game</h1><p>In <a href="https://mieszkogulinski.github.io/react-kulki/">this puzzle game</a>, the player has to move colorful balls on a grid. When there are 5 (or more) balls of the same color in a row (horizontally, vertically, diagonally), the series disappears and the player is awarded some score. After a move that doesn't result in a disappearing series, 3 more balls (in random location, in random color) appear on the board. The balls can be moved only when there's a clear path from one location to another - from one grid to another, they can move up, down, left or right.</p><p>One of the original implementations of this game was made for Windows 3.1, so it doesn't work on modern computers anymore. That's why I created a clone of that game, written in JavaScript and HTML, with <a href="https://reactjs.org/">React</a>. Feel free to play it in your free time!</p><h2>How does the pathfinding algorithm work?</h2><p>When the player selects a <strong>start</strong> and <strong>end</strong> grid cell, we generate a <strong>spanning tree</strong> of all possible moves from the start cell, and then we follow the path from the end cell to the start cell.</p><h3>What is a spanning tree?</h3><p>At first, let's interpret the game grid as a graph, where each non-occupied cell is a vertex of a graph, and the edges of the graph are possible path of movement between adjacent cells.</p><p>Here's a graph of possible movements on an empty grid:</p><p><img alt="pathfinding algorithm example - empty grid" src="/img/pathfinding-1.svg"></p><p>A spanning tree is a tree graph that covers all vertices of connected graph. Usually there can be multiple spanning trees of a given graph, but we need to generate only one, and it doesn't really matter for the game rules what this spanning tree is. A tree graph has a property that, between two selected vertices, there's <strong>only one unique path</strong>. That's why creating a spanning tree is useful for creating a path for a ball to another available cell.</p><p>Here's an example spanning tree of an empty grid:</p><p><img alt="pathfinding algorithm example - spanning tree" src="/img/pathfinding-2.svg"></p><p>This tree has a root in the top left corner, but its root can be moved to any of its vertices and it'll still be a spanning tree of the graph.</p><p>A spanning tree of a board, but with several balls blocking path to the bottom right corner, could look like that:</p><p><img alt="pathfinding algorithm example - spanning tree with blocked path" src="/img/pathfinding-3.svg"></p><h3>Tree generation algorithm</h3><p>The algorithm used in the puzzle game is:</p><ol><li>Start with the starting point</li><li>In each iteration, from each cell added in previous iteration (or the starting point), find possible paths from this point to another cell. Keep track of added cells for avoiding duplicates.</li><li>If no new paths are added in a next iteration, building a spanning tree is finished.</li></ol><p>In the implementation of the algorithm, the cells are numbered from 0 to 80, and list of paths from one cell to another, is kept in an object, in format:</p><pre><code>{ sourceCell: [targetCell1, targetCell2], ...}
</code></pre><p>For example, if we can make a move from cell 0 to cell 1 and 9, the object will have format:</p><pre><code>{ 0: [1, 9], ... }
</code></pre><p>For example, let's assume that we want to calculate paths from the top right corner. In the first iteration, starting from the starting point, we can go one right and one bottom:</p><p><img alt="pathfinding algorithm example - tree generation, iteration 1" src="/img/pathfinding-4.svg"></p><p>The code checks that a potential next cell is a valid cell (so we can't go outside the field), is not occupied by a ball, and hasn't been added to the tree yet. In the second iteration, we find the following fields connected to the previously added ones:</p><p><img alt="pathfinding algorithm example - tree generation, iteration 2" src="/img/pathfinding-5.svg"></p><p>And in the next iteration:</p><p><img alt="pathfinding algorithm example - tree generation, iteration 3" src="/img/pathfinding-6.svg"></p><p>When we find the target cell, we don't need to continue the algorithm, because the path from start to end cell will already be covered with the incomplete spanning tree. But if we create a spanning tree and don't find the target cell, it means that there is no path between selected cells, and the player cannot make such a move.</p><p>When the tree contains both the start and end cells, and the start cell is at the root, we can find the cells on every step from the end towards the root, and then reverse the array.</p><a href="/">Go back to home page</a></article><footer><div class="footer-content"><a href="https://www.radcode.co/">Do you need an app?</a></div></footer><link href="/styles/prism-atom-dark.css" rel="stylesheet"></body></html>