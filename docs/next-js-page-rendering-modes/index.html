<!doctype html><html lang="en"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1" name="viewport"><title>Next.js page rendering modes - a short guide</title><style>body,html{margin:0 0}body{color:#222;font-size:18px;line-height:1.5}.header-content,article,footer{margin:0 auto;padding:0 15px;max-width:710px}h1{border-bottom:2px solid #ffd744;padding-bottom:15px;font-size:32px}.blog-name{text-align:center;padding-bottom:25px}h2{font-size:24px}h3{font-size:20px}a{text-decoration:none;color:#927200;transition:color .25s ease-out}a:hover{color:#bb9200}code{font-size:14px}pre{overflow:auto}img{max-width:100%}.footer-content{margin-top:15px;border-top:2px solid #ffd744;padding-top:15px;padding-bottom:15px}.art-list-link{font-size:22px;margin-bottom:5px}.art-list-link a{color:#222;transition:color .2s ease-out}.art-list-link a:hover{color:#555}.art-list-date{font-size:16px}@media (prefers-color-scheme:dark){body{background:#222;color:#fff}a{color:#ffd744}a:hover{color:#bb9200}.art-list-link a{color:#fff}.art-list-link a:hover{color:#eee}}@media (min-width:768px){body{font-size:20px}code{font-size:16px}}</style><link href="/img/favicon.svg" rel="icon" type="image/svg+xml"><link href="/img/favicon.ico" rel="alternate icon"></head><body><article><h1>Next.js page rendering modes - a short guide</h1><p><a href="https://nextjs.org/">Next.js</a> is a framework that allows pre-rendering and server-side rendering of pages written in <a href="https://reactjs.org/">React</a>, and comes integrated with a HTTP server.</p><h2>Why is Next.js useful?</h2><p>With "raw" React - without using any other framework - the server returns an empty HTML page, and JavaScript code. Then the browser executes the JS code, and the code fills the page with final HTML content, and - when needed - queries an API to get required data. After the page gets initialized, React handles the page logic - form inputs, event handling etc.</p><p>Next.js, instead, already returns the initial HTML and CSS, and sends corresponding JavaScript code to handle the page logic, so that after loading it behaves like any other React page.</p><p>Because the HTML with final content is already sent to the user, the page content loads faster, and is more compatible with search engine crawlers.</p><p>Next.js, both when building and running on the server, can query an external resource - database, external API, files, or just anything Node.js can access. Then the returned data is inserted as the props of the outermost React component of the page, ready to be displayed.</p><h2>Rendering modes</h2><p>Next.js uses several page rendering modes:</p><ul><li><strong>static generation</strong> - a page is generated during <strong>build time</strong>,</li><li><strong>server-side rendering</strong> - a page is generated on-demand, every time it's requested,</li><li><strong>incremental static regeneration</strong> - a page is generated both during build time and after it's requested. After being generated, it's cached for a specified amount of time, then it's generated again when it's requested.</li></ul><p>In Next.js, <strong>generation</strong> means querying the resources and rendering React JS code to HTML.</p><p>Also, Next.js has a special path, <code>/api</code>, for API routes - that could be used for client-side requests. But using it for fetching initial data negates the benefit of Next.js server-side rendering. API routes are of course useful for e.g. fetching more data when a page displays paginated content, or for performing some action.</p><p>Rendering mode is dependent on what functions are exported from the JavaScript page corresponding to a given page. Each page can have one of these modes.</p><h3>Static generation</h3><p>A page will be statically generated, when either:</p><ul><li>it has an exported <code>getStaticProps</code> function,</li><li>it has neither <code>getStaticProps</code> or <code>getServerSideProps</code> exported.</li></ul><p>An asynchronous function <code>getStaticProps</code> queries the resources during build time. Typically, build process is performed during page (re)deployment. That's why this mode is most useful for pages with very slowly changing or constant content.</p><p>A page that can take a parameter in the path, e.g. <code>/blog/[slug]</code>, to be rendered during build time, requires a function that enumerates every possible value of the parameter. Then, for each possible value of the parameter, a page is individually generated. It's a limitation, but without knowing in advance what values can the parameter have, generating pages in advance isn't possible.</p><p>Pages without <code>getStaticProps</code> or <code>getServerSideProps</code> don't use Next.js for getting initial data - they'll just display what is there in their React code. On such pages, React is active on the client side, and can load data by querying an API.</p><h3>Server-side rendering</h3><p>This mode is triggered by having an exported <code>getServerSideProps</code> function. In this mode, every time the page is requested from the server, this function is called, and with the received props, React markup is rendered to HTML.</p><p>While this mode immediately reflects the changes in the data source, it may be <strong>very</strong> expensive to generate a page on each request.</p><p>Server-side rendering mode has an advantage that the server can read query parameters from the argument of <code>getServerSideProps</code>. For example, a page displaying search results, having URL like <code>/search?term=...</code>, could have this function implemented like that:</p><pre><code>export const getServerSideProps = async (context) => {
  const term = context.query.term;

  ... fetch the results dependent on term ...

  return {
    props: { ... },
  };
};
</code></pre><h3>Incremental static regeneration (cached mode)</h3><p>This mode generates the page during build time, but the pre-built page isn't stored permanently. After a specified time passes since last generation of the page, after the page is requested, the old version is sent to the user, but the page starts being generated again, and the new version is stored in a cache and will be available on the next request.</p><p>This mode is triggered by having <code>getStaticProps</code> with <code>revalidate</code> in the options, like that:</p><pre><code>export const getStaticProps = async () => {
  ... fetch the data here ...
  return {
    props: { ... },
    revalidate: 60,
  };
};
</code></pre><p>where <code>revalidate</code> is the cache expiration time in seconds.</p><h2>Limitations of server-side and build-time rendering</h2><p>During build time and server-side rendering, React markup (with props) is rendered to HTML, but the lifecycle methods executed on the component mounting aren't. Also, browser-side APIs aren't available.</p><h3>Lifecycle methods/hooks</h3><p>These are <code>useEffect</code>, for functional components, and <code>componentDidMount</code>, for class components. During server-side and build-time rendering they aren't executed, but they are executed on the client after the page initializes.</p><h3>Browser-side APIs</h3><p>Because server-side and build-time rendering happens in Node.js, not browser, environment, browser-specific APIs aren't available, and using them will result in errors such as <code>window is not defined</code>.</p><p>A React component that initializes its state with a value from <code>localStorage</code>, in a purely client-side React, can be written this way:</p><pre><code>const SomeSwitch = () => {
  const [switchValue, setSwitchValue] = useState(localStorage.getItem("switchValue"));
  ...
  ...
}
</code></pre><p>But in Next.js, rendering a component on the server will fail, as localStorage isn't available on the server. You must either rewrite the component so that it doesn't access browser-specific APIs on the server, or not render the component during initial rendering.</p><p>For example, this component can be modified like that:</p><pre><code>const SomeSwitch = () => {
  const [switchValue, setSwitchValue] = useState('default value');

  useEffect(() => {
    setSwitchValue(localStorage.getItem("switchValue"));
  }, []);

  ...
  ...
}
</code></pre><p>An additional limitation of Next.js is that during server-side rendering, it's not possible to get the current path parameters from <a href="https://nextjs.org/docs/api-reference/next/router#router-object">the router</a>.</p><h3>Writable filesystem</h3><p>Incremental static regeneration requires the file system to be writable. It's a limitation when deploying to certain environments, such as Google App Engine standard environment, with read-only filesystem except <code>/tmp</code> path (and Next.js cannot use it, as it doesn't support path configuration).</p><h2>Example</h2><p>I built a help page for some company, it features articles and blog posts, fetched from an external API (a headless CMS).</p><ul><li>For an article page, I used <strong>incremental static regeneration</strong>. This way, when an editor makes an update to the article, it'll be visible to the visitors after the cache expires. In this particular case, the expiration time was set to 10 minutes.</li><li>The same for article lists (global and from each category).</li><li>For the search page, I used <strong>server-side rendering</strong>, as it's not possible to predict what the user enters in the search input. The search page has a limited number of results displayed...</li><li>...and clicking "load more" button performs a call to an <strong>API route</strong>.</li><li>The error page is fully hardcoded in React and doesn't fetch any data, so it's <strong>statically generated</strong>.</li></ul><p>Every project has its own requirements, so it's always important to know what tools are available, and when to use them.</p><a href="/">Go back to home page</a></article><link href="/styles/prism-atom-dark.css" rel="stylesheet"><footer><div class="footer-content"><a href="https://www.radcode.co/">Do you need an app?</a></div></footer></body></html>